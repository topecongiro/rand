var N = null;var searchIndex = {};
searchIndex["rand"]={"doc":"Utilities for random number generation","items":[[8,"RngCore","rand","The core of a random number generator.",N,N],[10,"next_u32","","Return the next random `u32`.",0,[[["self"]],["u32"]]],[10,"next_u64","","Return the next random `u64`.",0,[[["self"]],["u64"]]],[10,"fill_bytes","","Fill `dest` with random data.",0,N],[10,"try_fill_bytes","","Fill `dest` entirely with random data.",0,N],[8,"CryptoRng","","A marker trait used to indicate that an [`RngCore`] or [`BlockRngCore`] implementation is supposed to be cryptographically secure.",N,N],[8,"SeedableRng","","A random number generator that can be explicitly seeded.",N,N],[16,"Seed","","Seed type, which is restricted to types mutably-dereferencable as `u8` arrays (we recommend `[u8; N]` for some `N`).",1,N],[10,"from_seed","","Create a new PRNG using the given seed.",1,N],[11,"from_rng","","Create a new PRNG seeded from another `Rng`.",1,[[["r"]],["result",["error"]]]],[4,"ErrorKind","","Error kind which can be matched over.",N,N],[13,"Unavailable","","Feature is not available; not recoverable.",2,N],[13,"Unexpected","","General failure; there may be a chance of recovery on retry.",2,N],[13,"Transient","","A transient failure which likely can be resolved or worked around.",2,N],[13,"NotReady","","Not ready yet: recommended to try again a little later.",2,N],[3,"Error","","Error type of random number generators",N,N],[12,"kind","","The error kind",3,N],[12,"msg","","The error message",3,N],[5,"thread_rng","","Retrieve the lazily-initialized thread-local random number generator, seeded by the system. Intended to be used in method chaining style, e.g. `thread_rng().gen::<i32>()`, or cached locally, e.g. `let mut rng = thread_rng();`.",N,[[],["threadrng"]]],[5,"random","","Generates a random value using the thread-local random number generator.",N,[[],["t"]]],[0,"distributions","","Generating random samples from probability distributions.",N,N],[3,"Alphanumeric","rand::distributions","Sample a `char`, uniformly distributed over ASCII letters and numbers: a-z, A-Z and 0-9.",N,N],[3,"Uniform","","Sample values uniformly between two bounds.",N,N],[3,"OpenClosed01","","A distribution to sample floating point numbers uniformly in the half-open interval `(0, 1]`, i.e. including 1 but not 0.",N,N],[3,"Open01","","A distribution to sample floating point numbers uniformly in the open interval `(0, 1)`, i.e. not including either endpoint.",N,N],[3,"Bernoulli","","The Bernoulli distribution.",N,N],[3,"WeightedIndex","","A distribution using weighted sampling to pick a discretely selected item.",N,N],[3,"Gamma","","The Gamma distribution `Gamma(shape, scale)` distribution.",N,N],[3,"ChiSquared","","The chi-squared distribution `χ²(k)`, where `k` is the degrees of freedom.",N,N],[3,"FisherF","","The Fisher F distribution `F(m, n)`.",N,N],[3,"StudentT","","The Student t distribution, `t(nu)`, where `nu` is the degrees of freedom.",N,N],[3,"Normal","","The normal distribution `N(mean, std_dev**2)`.",N,N],[3,"LogNormal","","The log-normal distribution `ln N(mean, std_dev**2)`.",N,N],[3,"StandardNormal","","Samples floating-point numbers according to the normal distribution `N(0, 1)` (a.k.a. a standard normal, or Gaussian). This is equivalent to `Normal::new(0.0, 1.0)` but faster.",N,N],[3,"Exp","","The exponential distribution `Exp(lambda)`.",N,N],[3,"Exp1","","Samples floating-point numbers according to the exponential distribution, with rate parameter `λ = 1`. This is equivalent to `Exp::new(1.0)` or sampling with `-rng.gen::<f64>().ln()`, but faster.",N,N],[3,"Pareto","","Samples floating-point numbers according to the Pareto distribution",N,N],[3,"Poisson","","The Poisson distribution `Poisson(lambda)`.",N,N],[3,"Binomial","","The binomial distribution `Binomial(n, p)`.",N,N],[3,"Cauchy","","The Cauchy distribution `Cauchy(median, scale)`.",N,N],[3,"Dirichlet","","The dirichelet distribution `Dirichlet(alpha)`.",N,N],[3,"DistIter","","An iterator that generates random values of `T` with distribution `D`, using `R` as the source of randomness.",N,N],[3,"Standard","","A generic random value distribution, implemented for many primitive types. Usually generates values with a numerically uniform distribution, and with a range appropriate to the type.",N,N],[3,"Weighted","","A value with a particular weight for use with `WeightedChoice`.",N,N],[12,"weight","","The numerical weight of this item",4,N],[12,"item","","The actual item which is being weighted",4,N],[3,"WeightedChoice","","A distribution that selects from a finite collection of weighted items.",N,N],[4,"WeightedError","","Error type returned from `WeightedIndex::new`.",N,N],[13,"NoItem","","The provided iterator contained no items.",5,N],[13,"NegativeWeight","","A weight lower than zero was used.",5,N],[13,"AllWeightsZero","","All items in the provided iterator had a weight of zero.",5,N],[0,"uniform","","A distribution uniformly sampling numbers within a given range.",N,N],[3,"Uniform","rand::distributions::uniform","Sample values uniformly between two bounds.",N,N],[3,"UniformInt","","The back-end implementing [`UniformSampler`] for integer types.",N,N],[3,"UniformFloat","","The back-end implementing [`UniformSampler`] for floating-point types.",N,N],[3,"UniformDuration","","The back-end implementing [`UniformSampler`] for `Duration`.",N,N],[8,"SampleUniform","","Helper trait for creating objects using the correct implementation of [`UniformSampler`] for the sampling type.",N,N],[16,"Sampler","","The `UniformSampler` implementation supporting type `X`.",6,N],[8,"UniformSampler","","Helper trait handling actual uniform sampling.",N,N],[16,"X","","The type sampled by this implementation.",7,N],[10,"new","","Construct self, with inclusive lower bound and exclusive upper bound `[low, high)`.",7,[[["b1"],["b2"]],["self"]]],[10,"new_inclusive","","Construct self, with inclusive bounds `[low, high]`.",7,[[["b1"],["b2"]],["self"]]],[10,"sample","","Sample a value.",7,N],[11,"sample_single","","Sample a single value uniformly from a range with inclusive lower bound and exclusive upper bound `[low, high)`.",7,N],[8,"SampleBorrow","","Helper trait similar to [`Borrow`] but implemented only for SampleUniform and references to SampleUniform in order to resolve ambiguity issues.",N,N],[10,"borrow","","Immutably borrows from an owned value. See [`Borrow::borrow`]",8,[[["self"]],["borrowed"]]],[11,"clone","","",9,[[["self"]],["uniform"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `Uniform` instance which samples uniformly from the half open range `[low, high)` (excluding `high`). Panics if `low >= high`.",9,[[["b1"],["b2"]],["uniform"]]],[11,"new_inclusive","","Create a new `Uniform` instance which samples uniformly from the closed range `[low, high]` (inclusive). Panics if `low > high`.",9,[[["b1"],["b2"]],["uniform"]]],[11,"sample","","",9,[[["self"],["r"]],["x"]]],[11,"from","","",9,[[["range"]],["uniform"]]],[11,"clone","","",10,[[["self"]],["uniformint"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"new","","",10,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",10,[[["b1"],["b2"]],["self"]]],[11,"sample","","",10,N],[11,"sample_single","","",10,N],[11,"clone","","",11,[[["self"]],["uniformfloat"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"new","","",11,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",11,[[["b1"],["b2"]],["self"]]],[11,"sample","","",11,N],[11,"sample_single","","",11,N],[11,"clone","","",12,[[["self"]],["uniformduration"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"new","","",12,[[["b1"],["b2"]],["self"]]],[11,"new_inclusive","","",12,[[["b1"],["b2"]],["self"]]],[11,"sample","","",12,[[["self"],["r"]],["duration"]]],[11,"clone","rand::distributions","",13,[[["self"]],["bernoulli"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `Bernoulli` with the given probability of success `p`.",13,[[["f64"]],["bernoulli"]]],[11,"from_ratio","","Construct a new `Bernoulli` with the probability of success of `numerator`-in-`denominator`. I.e. `new_ratio(2, 3)` will return a `Bernoulli` with a 2-in-3 chance, or about 67%, of returning `true`.",13,[[["u32"],["u32"]],["bernoulli"]]],[11,"sample","","",13,[[["self"],["r"]],["bool"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"clone","","",14,[[["self"]],["weightedindex"]]],[11,"new","","Creates a new a `WeightedIndex` [`Distribution`] using the values in `weights`. The weights can use any type `X` for which an implementation of [`Uniform<X>`] exists.",14,[[["i"]],["result",["weightedindex","weightederror"]]]],[11,"sample","","",14,[[["self"],["r"]],["usize"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"clone","","",5,[[["self"]],["weightederror"]]],[11,"eq","","",5,[[["self"],["weightederror"]],["bool"]]],[11,"description","","",5,[[["self"]],["str"]]],[11,"cause","","",5,[[["self"]],["option",["error"]]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"clone","","",15,[[["self"]],["gamma"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct an object representing the `Gamma(shape, scale)` distribution.",15,[[["f64"],["f64"]],["gamma"]]],[11,"sample","","",15,[[["self"],["r"]],["f64"]]],[11,"clone","","",16,[[["self"]],["chisquared"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new chi-squared distribution with degrees-of-freedom `k`. Panics if `k < 0`.",16,[[["f64"]],["chisquared"]]],[11,"sample","","",16,[[["self"],["r"]],["f64"]]],[11,"clone","","",17,[[["self"]],["fisherf"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `FisherF` distribution, with the given parameter. Panics if either `m` or `n` are not positive.",17,[[["f64"],["f64"]],["fisherf"]]],[11,"sample","","",17,[[["self"],["r"]],["f64"]]],[11,"clone","","",18,[[["self"]],["studentt"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new Student t distribution with `n` degrees of freedom. Panics if `n <= 0`.",18,[[["f64"]],["studentt"]]],[11,"sample","","",18,[[["self"],["r"]],["f64"]]],[11,"clone","","",19,[[["self"]],["standardnormal"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"sample","","",19,[[["self"],["r"]],["f64"]]],[11,"clone","","",20,[[["self"]],["normal"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `Normal` distribution with the given mean and standard deviation.",20,[[["f64"],["f64"]],["normal"]]],[11,"sample","","",20,[[["self"],["r"]],["f64"]]],[11,"clone","","",21,[[["self"]],["lognormal"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `LogNormal` distribution with the given mean and standard deviation.",21,[[["f64"],["f64"]],["lognormal"]]],[11,"sample","","",21,[[["self"],["r"]],["f64"]]],[11,"clone","","",22,[[["self"]],["exp1"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"sample","","",22,[[["self"],["r"]],["f64"]]],[11,"clone","","",23,[[["self"]],["exp"]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `Exp` with the given shape parameter `lambda`. Panics if `lambda <= 0`.",23,[[["f64"]],["exp"]]],[11,"sample","","",23,[[["self"],["r"]],["f64"]]],[11,"clone","","",24,[[["self"]],["pareto"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new Pareto distribution with given `scale` and `shape`.",24,[[["f64"],["f64"]],["pareto"]]],[11,"sample","","",24,[[["self"],["r"]],["f64"]]],[11,"clone","","",25,[[["self"]],["poisson"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `Poisson` with the given shape parameter `lambda`. Panics if `lambda <= 0`.",25,[[["f64"]],["poisson"]]],[11,"sample","","",25,[[["self"],["r"]],["u64"]]],[11,"clone","","",26,[[["self"]],["binomial"]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `Binomial` with the given shape parameters `n` (number of trials) and `p` (probability of success).",26,[[["u64"],["f64"]],["binomial"]]],[11,"sample","","",26,[[["self"],["r"]],["u64"]]],[11,"clone","","",27,[[["self"]],["cauchy"]]],[11,"fmt","","",27,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `Cauchy` with the given shape parameters `median` the peak location and `scale` the scale factor. Panics if `scale <= 0`.",27,[[["f64"],["f64"]],["cauchy"]]],[11,"sample","","",27,[[["self"],["r"]],["f64"]]],[11,"clone","","",28,[[["self"]],["dirichlet"]]],[11,"fmt","","",28,[[["self"],["formatter"]],["result"]]],[11,"new","","Construct a new `Dirichlet` with the given alpha parameter `alpha`.",28,[[["v"]],["dirichlet"]]],[11,"new_with_param","","Construct a new `Dirichlet` with the given shape parameter `alpha` and `size`.",28,[[["f64"],["usize"]],["dirichlet"]]],[11,"sample","","",28,[[["self"],["r"]],["vec",["f64"]]]],[11,"clone","","",29,[[["self"]],["openclosed01"]]],[11,"fmt","","",29,[[["self"],["formatter"]],["result"]]],[11,"clone","","",30,[[["self"]],["open01"]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result"]]],[11,"sample","","",31,[[["self"],["r"]],["f32"]]],[11,"sample","","",29,[[["self"],["r"]],["f32"]]],[11,"sample","","",30,[[["self"],["r"]],["f32"]]],[11,"sample","","",31,[[["self"],["r"]],["f64"]]],[11,"sample","","",29,[[["self"],["r"]],["f64"]]],[11,"sample","","",30,[[["self"],["r"]],["f64"]]],[11,"sample","","",31,[[["self"],["r"]],["f32x2"]]],[11,"sample","","",29,[[["self"],["r"]],["f32x2"]]],[11,"sample","","",30,[[["self"],["r"]],["f32x2"]]],[11,"sample","","",31,[[["self"],["r"]],["f32x4"]]],[11,"sample","","",29,[[["self"],["r"]],["f32x4"]]],[11,"sample","","",30,[[["self"],["r"]],["f32x4"]]],[11,"sample","","",31,[[["self"],["r"]],["f32x8"]]],[11,"sample","","",29,[[["self"],["r"]],["f32x8"]]],[11,"sample","","",30,[[["self"],["r"]],["f32x8"]]],[11,"sample","","",31,[[["self"],["r"]],["f32x16"]]],[11,"sample","","",29,[[["self"],["r"]],["f32x16"]]],[11,"sample","","",30,[[["self"],["r"]],["f32x16"]]],[11,"sample","","",31,[[["self"],["r"]],["f64x2"]]],[11,"sample","","",29,[[["self"],["r"]],["f64x2"]]],[11,"sample","","",30,[[["self"],["r"]],["f64x2"]]],[11,"sample","","",31,[[["self"],["r"]],["f64x4"]]],[11,"sample","","",29,[[["self"],["r"]],["f64x4"]]],[11,"sample","","",30,[[["self"],["r"]],["f64x4"]]],[11,"sample","","",31,[[["self"],["r"]],["f64x8"]]],[11,"sample","","",29,[[["self"],["r"]],["f64x8"]]],[11,"sample","","",30,[[["self"],["r"]],["f64x8"]]],[11,"sample","","",31,[[["self"],["r"]],["u8"]]],[11,"sample","","",31,[[["self"],["r"]],["u16"]]],[11,"sample","","",31,[[["self"],["r"]],["u32"]]],[11,"sample","","",31,[[["self"],["r"]],["u64"]]],[11,"sample","","",31,[[["self"],["r"]],["u128"]]],[11,"sample","","",31,[[["self"],["r"]],["usize"]]],[11,"sample","","",31,[[["self"],["r"]],["i8"]]],[11,"sample","","",31,[[["self"],["r"]],["i16"]]],[11,"sample","","",31,[[["self"],["r"]],["i32"]]],[11,"sample","","",31,[[["self"],["r"]],["i64"]]],[11,"sample","","",31,[[["self"],["r"]],["i128"]]],[11,"sample","","",31,[[["self"],["r"]],["isize"]]],[11,"sample","","",31,[[["self"],["r"]],["i8x2"]]],[11,"sample","","",31,[[["self"],["r"]],["u8x2"]]],[11,"sample","","",31,[[["self"],["r"]],["i16x2"]]],[11,"sample","","",31,[[["self"],["r"]],["u16x2"]]],[11,"sample","","",31,[[["self"],["r"]],["i8x4"]]],[11,"sample","","",31,[[["self"],["r"]],["u8x4"]]],[11,"sample","","",31,[[["self"],["r"]],["i32x2"]]],[11,"sample","","",31,[[["self"],["r"]],["u32x2"]]],[11,"sample","","",31,[[["self"],["r"]],["i16x4"]]],[11,"sample","","",31,[[["self"],["r"]],["u16x4"]]],[11,"sample","","",31,[[["self"],["r"]],["i8x8"]]],[11,"sample","","",31,[[["self"],["r"]],["u8x8"]]],[11,"sample","","",31,[[["self"],["r"]],["i64x2"]]],[11,"sample","","",31,[[["self"],["r"]],["u64x2"]]],[11,"sample","","",31,[[["self"],["r"]],["i32x4"]]],[11,"sample","","",31,[[["self"],["r"]],["u32x4"]]],[11,"sample","","",31,[[["self"],["r"]],["i16x8"]]],[11,"sample","","",31,[[["self"],["r"]],["u16x8"]]],[11,"sample","","",31,[[["self"],["r"]],["i8x16"]]],[11,"sample","","",31,[[["self"],["r"]],["u8x16"]]],[11,"sample","","",31,[[["self"],["r"]],["i64x4"]]],[11,"sample","","",31,[[["self"],["r"]],["u64x4"]]],[11,"sample","","",31,[[["self"],["r"]],["i32x8"]]],[11,"sample","","",31,[[["self"],["r"]],["u32x8"]]],[11,"sample","","",31,[[["self"],["r"]],["i16x16"]]],[11,"sample","","",31,[[["self"],["r"]],["u16x16"]]],[11,"sample","","",31,[[["self"],["r"]],["i8x32"]]],[11,"sample","","",31,[[["self"],["r"]],["u8x32"]]],[11,"sample","","",31,[[["self"],["r"]],["i64x8"]]],[11,"sample","","",31,[[["self"],["r"]],["u64x8"]]],[11,"sample","","",31,[[["self"],["r"]],["i32x16"]]],[11,"sample","","",31,[[["self"],["r"]],["u32x16"]]],[11,"sample","","",31,[[["self"],["r"]],["i16x32"]]],[11,"sample","","",31,[[["self"],["r"]],["u16x32"]]],[11,"sample","","",31,[[["self"],["r"]],["i8x64"]]],[11,"sample","","",31,[[["self"],["r"]],["u8x64"]]],[11,"fmt","","",32,[[["self"],["formatter"]],["result"]]],[11,"sample","","",31,[[["self"],["r"]],["char"]]],[11,"sample","","",32,[[["self"],["r"]],["char"]]],[11,"sample","","",31,[[["self"],["r"]],["bool"]]],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,N],[11,"sample","","",31,[[["self"],["r"]],["option"]]],[11,"sample","","",31,[[["self"],["r"]],["wrapping"]]],[8,"Distribution","","Types (distributions) that can be used to create a random instance of `T`.",N,N],[10,"sample","","Generate a random value of `T`, using `rng` as the source of randomness.",33,[[["self"],["r"]],["t"]]],[11,"sample_iter","","Create an iterator that generates random values of `T`, using `rng` as the source of randomness.",33,[[["self"],["r"]],["distiter"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"next","","",34,[[["self"]],["option"]]],[11,"size_hint","","",34,N],[11,"clone","","",31,[[["self"]],["standard"]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"clone","","",4,[[["self"]],["weighted"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `WeightedChoice`.",35,N],[11,"sample","","",35,[[["self"],["r"]],["t"]]],[0,"prelude","rand","Convenience re-export of common members",N,N],[0,"prng","","Pseudo-random number generators.",N,N],[3,"XorShiftRng","rand::prng","An Xorshift random number generator.",N,N],[0,"chacha","","The ChaCha random number generator.",N,N],[3,"ChaChaRng","rand::prng::chacha","A cryptographically secure random number generator that uses the ChaCha algorithm.",N,N],[3,"ChaChaCore","","The core of `ChaChaRng`, used with `BlockRng`.",N,N],[11,"clone","","",36,[[["self"]],["chacharng"]]],[11,"fmt","","",36,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",36,[[["self"]],["u32"]]],[11,"next_u64","","",36,[[["self"]],["u64"]]],[11,"fill_bytes","","",36,N],[11,"try_fill_bytes","","",36,N],[11,"from_seed","","",36,N],[11,"from_rng","","",36,[[["r"]],["result",["error"]]]],[11,"get_word_pos","","Get the offset from the start of the stream, in 32-bit words.",36,[[["self"]],["u128"]]],[11,"set_word_pos","","Set the offset from the start of the stream, in 32-bit words.",36,[[["self"],["u128"]]]],[11,"set_stream","","Set the stream number.",36,[[["self"],["u64"]]]],[11,"clone","","",37,[[["self"]],["chachacore"]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"generate","","",37,N],[11,"from_seed","","",37,N],[11,"from","","",36,[[["chachacore"]],["self"]]],[0,"hc128","rand::prng","The HC-128 random number generator.",N,N],[3,"Hc128Rng","rand::prng::hc128","A cryptographically secure random number generator that uses the HC-128 algorithm.",N,N],[3,"Hc128Core","","The core of `Hc128Rng`, used with `BlockRng`.",N,N],[11,"clone","","",38,[[["self"]],["hc128rng"]]],[11,"fmt","","",38,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",38,[[["self"]],["u32"]]],[11,"next_u64","","",38,[[["self"]],["u64"]]],[11,"fill_bytes","","",38,N],[11,"try_fill_bytes","","",38,N],[11,"from_seed","","",38,N],[11,"from_rng","","",38,[[["r"]],["result",["error"]]]],[11,"clone","","",39,[[["self"]],["hc128core"]]],[11,"fmt","","",39,[[["self"],["formatter"]],["result"]]],[11,"generate","","",39,N],[11,"from_seed","","Create an HC-128 random number generator with a seed. The seed has to be 256 bits in length, matching the 128 bit `key` followed by 128 bit `iv` when HC-128 where to be used as a stream cipher.",39,N],[0,"isaac","rand::prng","The ISAAC random number generator.",N,N],[3,"IsaacRng","rand::prng::isaac","A random number generator that uses the ISAAC algorithm.",N,N],[3,"IsaacCore","","The core of `IsaacRng`, used with `BlockRng`.",N,N],[11,"clone","","",40,[[["self"]],["isaacrng"]]],[11,"fmt","","",40,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",40,[[["self"]],["u32"]]],[11,"next_u64","","",40,[[["self"]],["u64"]]],[11,"fill_bytes","","",40,N],[11,"try_fill_bytes","","",40,N],[11,"from_seed","","",40,N],[11,"from_rng","","",40,[[["s"]],["result",["error"]]]],[11,"new_from_u64","","Create an ISAAC random number generator using an `u64` as seed. If `seed == 0` this will produce the same stream of random numbers as the reference implementation when used unseeded.",40,[[["u64"]],["self"]]],[11,"clone","","",41,[[["self"]],["isaaccore"]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result"]]],[11,"generate","","Refills the output buffer, `results`. See also the pseudocode desciption of the algorithm in the [`IsaacRng`] documentation.",41,[[["self"],["isaacarray"]]]],[11,"from_seed","","",41,N],[11,"from_rng","","",41,[[["r"]],["result",["error"]]]],[0,"isaac64","rand::prng","The ISAAC-64 random number generator.",N,N],[3,"Isaac64Rng","rand::prng::isaac64","A random number generator that uses ISAAC-64, the 64-bit variant of the ISAAC algorithm.",N,N],[3,"Isaac64Core","","The core of `Isaac64Rng`, used with `BlockRng`.",N,N],[11,"clone","","",42,[[["self"]],["isaac64rng"]]],[11,"fmt","","",42,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",42,[[["self"]],["u32"]]],[11,"next_u64","","",42,[[["self"]],["u64"]]],[11,"fill_bytes","","",42,N],[11,"try_fill_bytes","","",42,N],[11,"from_seed","","",42,N],[11,"from_rng","","",42,[[["s"]],["result",["error"]]]],[11,"new_from_u64","","Create an ISAAC-64 random number generator using an `u64` as seed. If `seed == 0` this will produce the same stream of random numbers as the reference implementation when used unseeded.",42,[[["u64"]],["self"]]],[11,"clone","","",43,[[["self"]],["isaac64core"]]],[11,"fmt","","",43,[[["self"],["formatter"]],["result"]]],[11,"generate","","Refills the output buffer, `results`. See also the pseudocode desciption of the algorithm in the [`Isaac64Rng`] documentation.",43,[[["self"],["isaacarray"]]]],[11,"new_from_u64","","Create an ISAAC-64 random number generator using an `u64` as seed. If `seed == 0` this will produce the same stream of random numbers as the reference implementation when used unseeded.",43,[[["u64"]],["self"]]],[11,"from_seed","","",43,N],[11,"from_rng","","",43,[[["r"]],["result",["error"]]]],[11,"clone","rand::prng","",44,[[["self"]],["xorshiftrng"]]],[11,"fmt","","",44,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",44,[[["self"]],["u32"]]],[11,"next_u64","","",44,[[["self"]],["u64"]]],[11,"fill_bytes","","",44,N],[11,"try_fill_bytes","","",44,N],[11,"from_seed","","",44,N],[11,"from_rng","","",44,[[["r"]],["result",["error"]]]],[0,"rngs","rand","Random number generators and adapters for common usage:",N,N],[3,"JitterRng","rand::rngs","A true random number generator based on jitter in the CPU execution time, and jitter in memory access time.",N,N],[3,"EntropyRng","","An interface returning random data from external source(s), provided specifically for securely seeding algorithmic generators (PRNGs).",N,N],[3,"SmallRng","","An RNG recommended when small state, cheap initialization and good performance are required. The PRNG algorithm in `SmallRng` is chosen to be efficient on the current platform, without consideration for cryptography or security. The size of its state is much smaller than for [`StdRng`].",N,N],[3,"StdRng","","The standard RNG. The PRNG algorithm in `StdRng` is chosen to be efficient on the current platform, to be statistically strong and unpredictable (meaning a cryptographically secure PRNG).",N,N],[3,"ThreadRng","","The type returned by [`thread_rng`], essentially just a reference to the PRNG in thread-local memory.",N,N],[3,"OsRng","","A random number generator that retrieves randomness straight from the operating system.",N,N],[4,"TimerError","","An error that can occur when [`JitterRng::test_timer`] fails.",N,N],[13,"NoTimer","","No timer available.",45,N],[13,"CoarseTimer","","Timer too coarse to use as an entropy source.",45,N],[13,"NotMonotonic","","Timer is not monotonically increasing.",45,N],[13,"TinyVariantions","","Variations of deltas of time too small.",45,N],[13,"TooManyStuck","","Too many stuck results (indicating no added entropy).",45,N],[0,"adapter","","Wrappers / adapters forming RNGs",N,N],[3,"ReadRng","rand::rngs::adapter","An RNG that reads random bytes straight from any type supporting `std::io::Read`, for example files.",N,N],[3,"ReseedingRng","","A wrapper around any PRNG that implements [`BlockRngCore`], that adds the ability to reseed it.",N,N],[11,"fmt","","",46,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `ReadRng` from a `Read`.",46,[[["r"]],["readrng"]]],[11,"next_u32","","",46,[[["self"]],["u32"]]],[11,"next_u64","","",46,[[["self"]],["u64"]]],[11,"fill_bytes","","",46,N],[11,"try_fill_bytes","","",46,N],[11,"fmt","","",47,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `ReseedingRng` from an existing PRNG, combined with a RNG to use as reseeder.",47,[[["r"],["u64"],["rsdr"]],["self"]]],[11,"reseed","","Reseed the internal PRNG.",47,[[["self"]],["result",["error"]]]],[11,"next_u32","","",47,[[["self"]],["u32"]]],[11,"next_u64","","",47,[[["self"]],["u64"]]],[11,"fill_bytes","","",47,N],[11,"try_fill_bytes","","",47,N],[11,"clone","","",47,[[["self"]],["reseedingrng"]]],[11,"fmt","rand::rngs","",48,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `EntropyRng`.",48,[[],["self"]]],[11,"default","","",48,[[],["self"]]],[11,"next_u32","","",48,[[["self"]],["u32"]]],[11,"next_u64","","",48,[[["self"]],["u64"]]],[11,"fill_bytes","","",48,N],[11,"try_fill_bytes","","",48,N],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"clone","","",49,[[["self"]],["jitterrng"]]],[11,"fmt","","",45,[[["self"],["formatter"]],["result"]]],[11,"clone","","",45,[[["self"]],["timererror"]]],[11,"eq","","",45,[[["self"],["timererror"]],["bool"]]],[11,"fmt","","",45,[[["self"],["formatter"]],["result"]]],[11,"description","","",45,[[["self"]],["str"]]],[11,"from","rand","",3,[[["timererror"]],["error"]]],[11,"new","rand::rngs","Create a new `JitterRng`. Makes use of `std::time` for a timer, or a platform-specific function with higher accuracy if necessary and available.",49,[[],["result",["jitterrng","timererror"]]]],[11,"new_with_timer","","Create a new `JitterRng`. A custom timer can be supplied, making it possible to use `JitterRng` in `no_std` environments.",49,N],[11,"set_rounds","","Configures how many rounds are used to generate each 64-bit value. This must be greater than zero, and has a big impact on performance and output quality.",49,[[["self"],["u8"]]]],[11,"test_timer","","Basic quality tests on the timer, by measuring CPU timing jitter a few hundred times.",49,[[["self"]],["result",["u8","timererror"]]]],[11,"timer_stats","","Statistical test: return the timer delta of one normal run of the `JitterRng` entropy collector.",49,[[["self"],["bool"]],["i64"]]],[11,"next_u32","","",49,[[["self"]],["u32"]]],[11,"next_u64","","",49,[[["self"]],["u64"]]],[11,"fill_bytes","","",49,N],[11,"try_fill_bytes","","",49,N],[0,"mock","","Mock random number generator",N,N],[3,"StepRng","rand::rngs::mock","A simple implementation of `RngCore` for testing purposes.",N,N],[11,"fmt","","",50,[[["self"],["formatter"]],["result"]]],[11,"clone","","",50,[[["self"]],["steprng"]]],[11,"new","","Create a `StepRng`, yielding an arithmetic sequence starting with `initial` and incremented by `increment` each time.",50,[[["u64"],["u64"]],["self"]]],[11,"next_u32","","",50,[[["self"]],["u32"]]],[11,"next_u64","","",50,[[["self"]],["u64"]]],[11,"fill_bytes","","",50,N],[11,"try_fill_bytes","","",50,N],[11,"clone","rand::rngs","",51,[[["self"]],["smallrng"]]],[11,"fmt","","",51,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",51,[[["self"]],["u32"]]],[11,"next_u64","","",51,[[["self"]],["u64"]]],[11,"fill_bytes","","",51,N],[11,"try_fill_bytes","","",51,N],[11,"from_seed","","",51,N],[11,"from_rng","","",51,[[["r"]],["result",["error"]]]],[11,"clone","","",52,[[["self"]],["stdrng"]]],[11,"fmt","","",52,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",52,[[["self"]],["u32"]]],[11,"next_u64","","",52,[[["self"]],["u64"]]],[11,"fill_bytes","","",52,N],[11,"try_fill_bytes","","",52,N],[11,"from_seed","","",52,N],[11,"from_rng","","",52,[[["r"]],["result",["error"]]]],[11,"clone","","",53,[[["self"]],["threadrng"]]],[11,"fmt","","",53,[[["self"],["formatter"]],["result"]]],[11,"next_u32","","",53,[[["self"]],["u32"]]],[11,"next_u64","","",53,[[["self"]],["u64"]]],[11,"fill_bytes","","",53,N],[11,"try_fill_bytes","","",53,N],[11,"clone","","",54,[[["self"]],["osrng"]]],[11,"fmt","","",54,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `OsRng`.",54,[[],["result",["osrng","error"]]]],[11,"next_u32","","",54,[[["self"]],["u32"]]],[11,"next_u64","","",54,[[["self"]],["u64"]]],[11,"fill_bytes","","",54,N],[11,"try_fill_bytes","","",54,N],[0,"seq","rand","Functions for randomly accessing and sampling sequences.",N,N],[3,"SliceChooseIter","rand::seq","Iterator over multiple choices, as returned by `SliceRandom::choose_multiple.",N,N],[5,"sample_iter","","Randomly sample `amount` elements from a finite iterator.",N,[[["r"],["i"],["usize"]],["result",["vec","vec"]]]],[5,"sample_slice","","Randomly sample exactly `amount` values from `slice`.",N,N],[5,"sample_slice_ref","","Randomly sample exactly `amount` references from `slice`.",N,N],[5,"sample_indices","","Randomly sample exactly `amount` indices from `0..length`.",N,[[["r"],["usize"],["usize"]],["vec",["usize"]]]],[8,"SliceRandom","","Extension trait on slices, providing random mutation and sampling methods.",N,N],[16,"Item","","The element type.",55,N],[10,"choose","","Returns a reference to one random element of the slice, or `None` if the slice is empty.",55,[[["self"],["r"]],["option"]]],[10,"choose_mut","","Returns a mutable reference to one random element of the slice, or `None` if the slice is empty.",55,[[["self"],["r"]],["option"]]],[10,"choose_multiple","","Produces an iterator that chooses `amount` elements from the slice at random without repeating any.",55,[[["self"],["r"],["usize"]],["slicechooseiter"]]],[10,"choose_weighted","","Similar to [`choose`], where the likelihood of each outcome may be specified. The specified function `weight` maps items `x` to a relative likelihood `weight(x)`. The probability of each item being selected is therefore `weight(x) / s`, where `s` is the sum of all `weight(x)`.",55,[[["self"],["r"],["f"]],["result",["weightederror"]]]],[10,"choose_weighted_mut","","Similar to [`choose_mut`], where the likelihood of each outcome may be specified. The specified function `weight` maps items `x` to a relative likelihood `weight(x)`. The probability of each item being selected is therefore `weight(x) / s`, where `s` is the sum of all `weight(x)`.",55,[[["self"],["r"],["f"]],["result",["weightederror"]]]],[10,"shuffle","","Shuffle a mutable slice in place.",55,[[["self"],["r"]]]],[10,"partial_shuffle","","Shuffle a slice in place, but exit early.",55,N],[8,"IteratorRandom","","Extension trait on iterators, providing random sampling methods.",N,N],[11,"choose","","Choose one element at random from the iterator. If you have a slice, it's significantly faster to call the [`choose`] or [`choose_mut`] functions using the slice instead.",56,[[["self"],["r"]],["option"]]],[11,"choose_multiple_fill","","Collects `amount` values at random from the iterator into a supplied buffer.",56,N],[11,"choose_multiple","","Collects `amount` values at random from the iterator into a vector.",56,[[["self"],["r"],["usize"]],["vec"]]],[11,"fmt","","",57,[[["self"],["formatter"]],["result"]]],[11,"next","","",57,[[["self"]],["option"]]],[11,"size_hint","","",57,N],[11,"len","","",57,[[["self"]],["usize"]]],[8,"Rng","rand","An automatically-implemented extension trait on [`RngCore`] providing high-level generic methods for sampling values and other convenience methods.",N,N],[11,"gen","","Return a random value supporting the [`Standard`] distribution.",58,[[["self"]],["t"]]],[11,"gen_range","","Generate a random value in the range [`low`, `high`), i.e. inclusive of `low` and exclusive of `high`.",58,[[["self"],["b1"],["b2"]],["t"]]],[11,"sample","","Sample a new value, using the given distribution.",58,[[["self"],["d"]],["t"]]],[11,"sample_iter","","Create an iterator that generates values using the given distribution.",58,[[["self"],["d"]],["distiter"]]],[11,"fill","","Fill `dest` entirely with random bytes (uniform value distribution), where `dest` is any type supporting [`AsByteSliceMut`], namely slices and arrays over primitive integer types (`i8`, `i16`, `u32`, etc.).",58,[[["self"],["t"]]]],[11,"try_fill","","Fill `dest` entirely with random bytes (uniform value distribution), where `dest` is any type supporting [`AsByteSliceMut`], namely slices and arrays over primitive integer types (`i8`, `i16`, `u32`, etc.).",58,[[["self"],["t"]],["result",["error"]]]],[11,"gen_bool","","Return a bool with a probability `p` of being true.",58,[[["self"],["f64"]],["bool"]]],[11,"gen_ratio","","Return a bool with a probability of `numerator/denominator` of being true. I.e. `gen_ratio(2, 3)` has chance of 2 in 3, or about 67%, of returning true. If `numerator == denominator`, then the returned value is guaranteed to be `true`. If `numerator == 0`, then the returned value is guaranteed to be `false`.",58,[[["self"],["u32"],["u32"]],["bool"]]],[11,"choose","","Return a random element from `values`.",58,N],[11,"choose_mut","","Return a mutable pointer to a random element from `values`.",58,N],[11,"shuffle","","Shuffle a mutable slice in place.",58,N],[8,"AsByteSliceMut","","Trait for casting types to byte slices",N,N],[10,"as_byte_slice_mut","","Return a mutable reference to self as a byte slice",59,N],[10,"to_le","","Call `to_le` on each element (i.e. byte-swap on Big Endian platforms).",59,[[["self"]]]],[8,"FromEntropy","","A convenience extension to [`SeedableRng`] allowing construction from fresh entropy. This trait is automatically implemented for any PRNG implementing [`SeedableRng`] and is not intended to be implemented by users.",N,N],[10,"from_entropy","","Creates a new instance, automatically seeded with fresh entropy.",60,[[],["self"]]],[11,"read","","",0,N],[11,"fmt","","",3,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result",["error"]]]],[11,"clone","","",2,[[["self"]],["errorkind"]]],[11,"eq","","",2,[[["self"],["errorkind"]],["bool"]]],[11,"description","","",3,[[["self"]],["str"]]],[11,"cause","","",3,[[["self"]],["option",["error"]]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result",["error"]]]],[11,"should_retry","","True if this kind of error may resolve itself on retry.",2,[[["self"]],["bool"]]],[11,"should_wait","","True if we should retry but wait before retrying",2,[[["self"]],["bool"]]],[11,"description","","A description of this error kind",2,[[["self"]],["str"]]],[11,"new","","Create a new instance, with specified kind and a message.",3,[[["errorkind"],["str"]],["error"]]],[11,"with_cause","","Create a new instance, with specified kind, message, and a chained cause.",3,[[["errorkind"],["str"],["e"]],["error"]]],[11,"take_cause","","Take the cause, if any. This allows the embedded cause to be extracted. This uses `Option::take`, leaving `self` with no cause.",3,[[["self"]],["option",["box"]]]]],"paths":[[8,"RngCore"],[8,"SeedableRng"],[4,"ErrorKind"],[3,"Error"],[3,"Weighted"],[4,"WeightedError"],[8,"SampleUniform"],[8,"UniformSampler"],[8,"SampleBorrow"],[3,"Uniform"],[3,"UniformInt"],[3,"UniformFloat"],[3,"UniformDuration"],[3,"Bernoulli"],[3,"WeightedIndex"],[3,"Gamma"],[3,"ChiSquared"],[3,"FisherF"],[3,"StudentT"],[3,"StandardNormal"],[3,"Normal"],[3,"LogNormal"],[3,"Exp1"],[3,"Exp"],[3,"Pareto"],[3,"Poisson"],[3,"Binomial"],[3,"Cauchy"],[3,"Dirichlet"],[3,"OpenClosed01"],[3,"Open01"],[3,"Standard"],[3,"Alphanumeric"],[8,"Distribution"],[3,"DistIter"],[3,"WeightedChoice"],[3,"ChaChaRng"],[3,"ChaChaCore"],[3,"Hc128Rng"],[3,"Hc128Core"],[3,"IsaacRng"],[3,"IsaacCore"],[3,"Isaac64Rng"],[3,"Isaac64Core"],[3,"XorShiftRng"],[4,"TimerError"],[3,"ReadRng"],[3,"ReseedingRng"],[3,"EntropyRng"],[3,"JitterRng"],[3,"StepRng"],[3,"SmallRng"],[3,"StdRng"],[3,"ThreadRng"],[3,"OsRng"],[8,"SliceRandom"],[8,"IteratorRandom"],[3,"SliceChooseIter"],[8,"Rng"],[8,"AsByteSliceMut"],[8,"FromEntropy"]]};
searchIndex["rand_core"]={"doc":"Random number generation traits","items":[[3,"Error","rand_core","Error type of random number generators",N,N],[12,"kind","","The error kind",0,N],[12,"msg","","The error message",0,N],[4,"ErrorKind","","Error kind which can be matched over.",N,N],[13,"Unavailable","","Feature is not available; not recoverable.",1,N],[13,"Unexpected","","General failure; there may be a chance of recovery on retry.",1,N],[13,"Transient","","A transient failure which likely can be resolved or worked around.",1,N],[13,"NotReady","","Not ready yet: recommended to try again a little later.",1,N],[11,"eq","","",1,[[["self"],["errorkind"]],["bool"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"clone","","",1,[[["self"]],["errorkind"]]],[11,"should_retry","","True if this kind of error may resolve itself on retry.",1,[[["self"]],["bool"]]],[11,"should_wait","","True if we should retry but wait before retrying",1,[[["self"]],["bool"]]],[11,"description","","A description of this error kind",1,[[["self"]],["str"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new instance, with specified kind and a message.",0,[[["errorkind"],["str"]],["self"]]],[11,"with_cause","","Create a new instance, with specified kind, message, and a chained cause.",0,[[["errorkind"],["str"],["e"]],["self"]]],[11,"take_cause","","Take the cause, if any. This allows the embedded cause to be extracted. This uses `Option::take`, leaving `self` with no cause.",0,[[["self"]],["option",["box"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"description","","",0,[[["self"]],["str"]]],[11,"cause","","",0,[[["self"]],["option",["stderror"]]]],[0,"block","","The `BlockRngCore` trait and implementation helpers",N,N],[3,"BlockRng","rand_core::block","A wrapper type implementing [`RngCore`] for some type implementing [`BlockRngCore`] with `u32` array buffer; i.e. this can be used to implement a full RNG from just a `generate` function.",N,N],[12,"core","","The core part of the RNG, implementing the `generate` function.",2,N],[3,"BlockRng64","","A wrapper type implementing [`RngCore`] for some type implementing [`BlockRngCore`] with `u64` array buffer; i.e. this can be used to implement a full RNG from just a `generate` function.",N,N],[12,"core","","The core part of the RNG, implementing the `generate` function.",3,N],[8,"BlockRngCore","","A trait for RNGs which do not generate random numbers individually, but in blocks (typically `[u32; N]`). This technique is commonly used by cryptographic RNGs to improve performance.",N,N],[16,"Item","","Results element type, e.g. `u32`.",4,N],[16,"Results","","Results type. This is the 'block' an RNG implementing `BlockRngCore` generates, which will usually be an array like `[u32; 16]`.",4,N],[10,"generate","","Generate a new block of results.",4,N],[11,"clone","","",2,[[["self"]],["blockrng"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `BlockRng` from an existing RNG implementing `BlockRngCore`. Results will be generated on first use.",2,[[["r"]],["blockrng"]]],[11,"index","","Get the index into the result buffer.",2,[[["self"]],["usize"]]],[11,"reset","","Reset the number of available results. This will force a new set of results to be generated on next use.",2,[[["self"]]]],[11,"generate_and_set","","Generate a new set of results immediately, setting the index to the given value.",2,[[["self"],["usize"]]]],[11,"next_u32","","",2,[[["self"]],["u32"]]],[11,"next_u64","","",2,[[["self"]],["u64"]]],[11,"fill_bytes","","",2,N],[11,"try_fill_bytes","","",2,N],[11,"from_seed","","",2,N],[11,"from_rng","","",2,[[["s"]],["result",["error"]]]],[11,"clone","","",3,[[["self"]],["blockrng64"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `BlockRng` from an existing RNG implementing `BlockRngCore`. Results will be generated on first use.",3,[[["r"]],["blockrng64"]]],[11,"index","","Get the index into the result buffer.",3,[[["self"]],["usize"]]],[11,"reset","","Reset the number of available results. This will force a new set of results to be generated on next use.",3,[[["self"]]]],[11,"generate_and_set","","Generate a new set of results immediately, setting the index to the given value.",3,[[["self"],["usize"]]]],[11,"next_u32","","",3,[[["self"]],["u32"]]],[11,"next_u64","","",3,[[["self"]],["u64"]]],[11,"fill_bytes","","",3,N],[11,"try_fill_bytes","","",3,N],[11,"from_seed","","",3,N],[11,"from_rng","","",3,[[["s"]],["result",["error"]]]],[0,"impls","rand_core","Helper functions for implementing `RngCore` functions.",N,N],[5,"next_u64_via_u32","rand_core::impls","Implement `next_u64` via `next_u32`, little-endian order.",N,[[["r"]],["u64"]]],[5,"fill_bytes_via_next","","Implement `fill_bytes` via `next_u64` and `next_u32`, little-endian order.",N,N],[5,"fill_via_u32_chunks","","Implement `fill_bytes` by reading chunks from the output buffer of a block based RNG.",N,N],[5,"fill_via_u64_chunks","","Implement `fill_bytes` by reading chunks from the output buffer of a block based RNG.",N,N],[5,"next_u32_via_fill","","Implement `next_u32` via `fill_bytes`, little-endian order.",N,[[["r"]],["u32"]]],[5,"next_u64_via_fill","","Implement `next_u64` via `fill_bytes`, little-endian order.",N,[[["r"]],["u64"]]],[0,"le","rand_core","Little-Endian utilities",N,N],[5,"read_u32_into","rand_core::le","Reads unsigned 32 bit integers from `src` into `dst`. Borrowed from the `byteorder` crate.",N,N],[5,"read_u64_into","","Reads unsigned 64 bit integers from `src` into `dst`. Borrowed from the `byteorder` crate.",N,N],[8,"RngCore","rand_core","The core of a random number generator.",N,N],[10,"next_u32","","Return the next random `u32`.",5,[[["self"]],["u32"]]],[10,"next_u64","","Return the next random `u64`.",5,[[["self"]],["u64"]]],[10,"fill_bytes","","Fill `dest` with random data.",5,N],[10,"try_fill_bytes","","Fill `dest` entirely with random data.",5,N],[8,"CryptoRng","","A marker trait used to indicate that an [`RngCore`] or [`BlockRngCore`] implementation is supposed to be cryptographically secure.",N,N],[8,"SeedableRng","","A random number generator that can be explicitly seeded.",N,N],[16,"Seed","","Seed type, which is restricted to types mutably-dereferencable as `u8` arrays (we recommend `[u8; N]` for some `N`).",6,N],[10,"from_seed","","Create a new PRNG using the given seed.",6,N],[11,"from_rng","","Create a new PRNG seeded from another `Rng`.",6,[[["r"]],["result",["error"]]]],[11,"read","","",5,N]],"paths":[[3,"Error"],[4,"ErrorKind"],[3,"BlockRng"],[3,"BlockRng64"],[8,"BlockRngCore"],[8,"RngCore"],[8,"SeedableRng"]]};
initSearch(searchIndex);
